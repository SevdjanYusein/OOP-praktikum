const size_t maxNameSize=20;
const size_t maxCountOfProducts=64;

class Product
{
private:
	char name[maxNameSize];
	int expiryDate;
	double fat;
	bool isFood;
	double price;
public:
	Product(char,int,double,bool,double);
	void setname(char);
	void setexpiryDate(int);
	void setfat(double);
	void setisFood(bool);
	void setprice(double);

	char* getName() const
	{
		return this->name;
	}


};

class Store
{
private:
	int countOfProducts;
	Product products[maxCountOfProducts];
	double storeTurnover;
public:

};
__________________________________________________________________________________________________

{- Рекурсивни функции върху числа -}

{- Примери -}
-- 1. Функция, която връща сумата на числата от a до b.
-- Вариант 1. стандартна рекурсия
sum' :: Integer -> Integer -> Integer
sum' a b
    | a > b     = 0                 -- базов случай / дъно на рекурсията
    | otherwise = a + sum' (a + 1) b -- общ случай

-- Вариант 2. опашкова рекурсия:
sum'' :: Integer -> Integer -> Integer
sum'' a b = helper a 0 where
    helper i res =
        if i > b
            then res                        -- в дъното връшаме натрупания резултат (акумулатор)
            else helper (i + 1) (res + i)   -- в общия случай викаме рекурсивно функцията със стойностите от слвдващата "итерация"


-- 2. Функция, която връща факториела на числото n.
-- Вариант 1. стандартна рекурсия
factorial' :: Integer -> Integer
factorial' n =
    if n == 0
    then 1                          -- базов случай / дъно на рекурсията
    else n * factorial' (n - 1)      -- общ случай

factorial'' :: Integer -> Integer
factorial'' n = helper 1 1 where
    helper i res
        | i > n     = res
        | otherwise = helper (i + 1) (res * i)


{- Задачи -}
{-
Задача 1. Най-голям общ делител: Напишете функцията findGCD a b, която приема 2 цели
числа а и b и връща най-големия им общ делител. За целта може да използвате
алгоритъма на Евклид, който гласи, че най-големият общ делител на а и b е 
най-големия общ делител на b и а остатък b ако а не се дели на b или b, ако се.

Не можете да използвате функцията gcd от Прелюдията, която прави точно това.

Примери:
    findGCD 2 1     -> 1
    findGCD 5 15    -> 5
    findGCD 15 35   -> 5
-}
findGCD :: Integer -> Integer -> Integer
findGCD a b = if b == 0 then a else findGCD b (a `mod` b)


{-
Задача 2. Напишете функция, която обръща цифрите на числото n.
Note: Напишете си помощни функции firstDigits и lastDigit.

Примери:
    reverseDigits 0     -> 0
    reverseDigits 5     -> 5
    reverseDigits 12345 -> 54321
    reverseDigits 1212  -> 2121
    reverseDigits 1000  -> 1
-}
lastDigit :: Integer -> Integer
lastDigit n = n `mod` 10

firstDigits :: integer -> Integer
firstDigits n = n `div` 10

reverseDigits :: Integer -> Integer
reverseDigits n = helper 0 n where 
    helper result number = 
       if number == 0
       then result
       else helper (10* result + lastDigit number) (firstDigits number)
       
{-
Задача 3. Прости числа: дефинирайте функцията isPrime n, която приема цялото число n
и проверява дали то е просто.

Примери:
    isPrime 1   -> False
    isPrime 2   -> True
    isPrime 3   -> True
    isPrime 52  -> False
    isPrime 71  -> True
-}
isPrime :: Integer -> Bool
isPrime n = n >= 2 && helper 2 where
    helper i
       | i > sqrtn = True
       | n `mod` i == 0 = False
       | otherwise = helper (i + 1)
    sqrtn = floor (sqrt (fromIntegral n))


{- 
Задача 4. Дефинирайте функцияга sumPrimes a b, която връща сумата на всички прости числа
в интервала от a до b.

Примери:
    sumPrimes 1 10  -> 17
    sumPrimes 2 5   -> 10
-}
sumPrimes :: Integer -> Integer -> Integer
sumPrimes a b 
    | a > b = 0
    | isPrime a = a+ sumPrimes (a + 1) b
    | otherwise = sumPrimes (a + 1) b

{-
Задача 5. Да се дефинира функцията isPerfectNumber n, която приема целочисления аргумент n и
връща дали той е перфектно число. Перфектно число се нарича всяко чяло число, равно на сбора на
собствeните си делители.

Примери:
    isPerfectNumber 6    -> True
    isPerfectNumber 8    -> False
    isPerfectNumber 28   -> True
    isPerfectNumber 500  -> False
-}
isPerfectNumber :: Integer -> Bool
isPerfectNumber n = sumDivisors 1 == n where
    sumDivisors i
       | i == n = 0
       | n `mod` i == 0 = i + sumDivisors (i + 1)
       | otherwise = sumDivisors (i + 1)

-- примери от условията на задачите
main = do
    -- Задача 1.
    print (findGCD 2 1)
    print (findGCD 5 15)
    print (findGCD 15 35)

    -- -- Задача 2.
    print (reverseDigits 0)
    print (reverseDigits 5)
    print (reverseDigits 12345)
    print (reverseDigits 1212)
    print (reverseDigits 1000)

    -- -- Задача 3.
    print (isPrime 1)
    print (isPrime 2)
    print (isPrime 3)
    print (isPrime 52)
    print (isPrime 71)

    -- -- Задача 4.
    print (sumPrimes 1 10)
    print (sumPrimes 2 5)

    -- -- Задача 5.
    print (isPerfectNumber 6)
    print (isPerfectNumber 8)
    print (isPerfectNumber 28)
    print (isPerfectNumber 500)


______________________________________________________________________________________________________

lastDigit :: Integer -> Integer
lastDigit n = n `mod` 10

firstDigits :: Integer -> Integer
firstDigits n = n `div` 10

numDigits :: Integer -> Integer
numDigits n =
    if n < 10 
    then 1
    else 1 + numDigits (firstDigits n)


{-
Задача. 1. Да се напише предикат isAscending, който връща истина, ако цифрите на
дадено естествено число са в нарастващ ред от първата към последната.

    isAscending 5    -> True
    isAscending 121  -> False
    isAscending 122  -> True
    isAscending 123  -> True
-}
isAscending :: Integer -> Bool
isAscending n =
     if n < 10
     then True
     else (lastDigit n) >= (lastDigit(firstDigits n)) && isAscending (firstDigits n)
{-
Задача. 2. Да се напише функция countOccurrences, намираща броя на срещанията на дадена
цифра d в записа на число n.

    countOccurrences 5 5      -> 1
    countOccurrences 5 25525  -> 3
    countOccurrences 5 12346  -> 0
-}
countOccurrences :: Integer -> Integer -> Integer
countOccurrences d n = if n >= 10
                       then if d == lastDigit n
                            then 1 + countOccurrences d (firstDigits n)
                            else countOccurrences d (firstDigits n)
                       else if d == n
                            then 1
                            else 0
{-
Задача. 3. Напишете функция, която за дадено неотрицателно цяло число проверява
дали на всяка четна позиция в десетичния запис на числото стои нечетна цифра. 
Нека старшата (най-лявата) цифра на числото има позиция 0.

    evenPosOddDigits 5    -> True
    evenPosOddDigits 6    -> False
    evenPosOddDigits 123  -> True
    evenPosOddDigits 122  -> False
-}
evenPosOddDigits :: Integer -> Bool
evenPosOddDigits n 
        | n < 10 = odd n
        | even lastIndex && even (lastDigit n) = False
        | otherwise = evenPosOddDigits (firstDigits n)
        where lastIndex = (numDigits n) - 1

{-
Задача 4. Да се дефинира функция която взима числото, което се образува
от последните n цифри на числото m.

    takeNFromEnd 1 123  -> 3
    takeNFromEnd 2 123  -> 23
    takeNFromEnd 3 123  -> 123
-}
takeNFromEnd :: Integer -> Integer -> Integer
takeNFromEnd n m 
      | n == 0 = 0
      | otherwise = (lastDigit m)  + (takeNFromEnd (n - 1) (firstDigits m)) * 10
{-
Задача. 5. Да се дефинира предикат isAutomorphic, който приема число n и
проверява дали n^2 завършва с цифрите на n.

    isAutomorphic 2   -> False
    isAutomorphic 5   -> True
    isAutomorphic 25  -> True
    isAutomorphic 26  -> False
-}

isAutomorphic :: Integer -> Bool
isAutomorphic n = n == takeNFromEnd (numDigits n) (n ^ 2)

{-
Задача. 6. Да се дефинира функция, която намира броя на срещанията
на многоцифрено число в записа на число n. (Като в задача 2, но не само
с едноцифрени числа.)

    print $ countOccurrences' 11 1111    -> 3
    print $ countOccurrences' 25 125625  -> 2
    print $ countOccurrences' 300 23     -> 0
-}
countOccurrences' :: Integer -> Integer -> Integer
countOccurrences' d n = 


main = do
    print $ isAscending 5
    print $ isAscending 121
    print $ isAscending 122
    print $ isAscending 123

    print $ countOccurrences 5 5
    print $ countOccurrences 5 25525
    print $ countOccurrences 5 12346

    print $ evenPosOddDigits 5
    print $ evenPosOddDigits 6
    print $ evenPosOddDigits 123
    print $ evenPosOddDigits 122

    print $ takeNFromEnd 1 123
    print $ takeNFromEnd 2 123 
    print $ takeNFromEnd 3 123 

    print $ isAutomorphic 2
    print $ isAutomorphic 5
    print $ isAutomorphic 25
    print $ isAutomorphic 26

    print $ countOccurrences' 11 1111
    print $ countOccurrences' 25 125625
    print $ countOccurrences' 300 23
    
_________________________________________________________________________________________________________________________

{- Задачи -}

lastDigit :: Integer -> Integer
lastDigit n = n `mod` 10

firstDigits :: Integer -> Integer
firstDigits n = n `div` 10

numDigits :: Integer -> Integer
numDigits n =
    if n < 10 
    then 1
    else 1 + numDigits (firstDigits n)

{-
Задача 1. Да се дефинира функцията listLength xs, която приема списък xs и
връща неговата дължина (подобно на функцията length от стандартната Прелюдия).

Примери:
    listLength [] = 0
    listLength [1, 2, 3, 4] = 4
-}
listLength :: [a] -> Int
listLength xs 
    | null xs = 0
    | otherwise = 1 + listLength (tail xs)


{-
Задача 2. Да се дефинира функцията isElementOf x xs, която приема дадено число x
и списък от числа xs и връща дали x се съдържа в xs (подобно на функцията elem).

Примери:
    3 `isElementOf` [1, 2, 3, 4] = True
    5 `isElementOf` [1, 2, 3, 4] = False
-}
isElementOf :: Integer -> [Integer] -> Bool
isElementOf x xs 
    | null xs = False
    | head xs == x = True
    | otherwise = isElementOf x (tail xs)


{-
Задача 3. Да се дефинира функция interval a b, която връща списък с числата в
интервала [a .. b] (за целта НЕ може да използвате израза [a .. b]).

Примери:
    interval 1 4 = [1, 2, 3, 4]
    interval 2 5 = [2, 3, 4, 5]
    interval 5 2 = []
-}
interval :: Integer -> Integer -> [Integer]
interval a b 
    | a > b = []
    | otherwise = [a] ++ interval (a + 1) b
   -- a:interval (a+1) b 
{-
Задача 4. Да се дефинира функция digits n, която връща списък с цифрите на
цялото число n >= 0.

Примери:
    digits 1234 = [1, 2, 3, 4]
    digits 1750 = [1, 7, 5, 0]
-}
digits :: Integer -> [Integer]
digits n 
    | n < 10 = [n]
    | otherwise = digits (firstDigits n) ++ [lastDigit n]
{-
Задача 5. Да се дефинира функция removeDuplicates xs, която приема списък от
числа xs, и връща списък от числа, в който са премахнати всички дупликати в xs.

Примери:
    removeDuplicates [1, 2, 1] = [1, 2]
    removeDuplicates [1, 3, 7, 3, 5, 1] = [1, 3, 7, 5]
-}
removeDuplicates :: [Integer] -> [Integer]
removeDuplicates xs 
    | null xs = []
    | head xs `elem` tail xs = removeDuplicates (tail xs)
    | otherwise = head xs : removeDuplicates (tail xs)
    ramDup' xs = reverse (removeDuplicates (reverse xs))


{-
Задача 6*. Mergesort: mergesort e един от най-ефикасните алгоритми за сортиране, особено що се отнася до
функционални езици. Функцията sort от модула Data.List, която е стандартния начин за сортиране на списъци
в Haskell, използва - макар и малко по-оптимизиран от този, който ще имплементирате - вариант на този алгоритъм.

а). Нaпишете функцията merge xs ys, която приема два списъка подредени в нарастващ ред и ги
обединява в един списък, чийто елементи също са подредени в нарастващ ред.

Пример:
    merge [1, 3, 7] [2, 4, 6] = [1, 2, 3, 4, 6, 7]

б). Използвайте функцията от предишната подточка и идеята, че мога да сортирам списък като го
разделя на две половини, сортирам всяка от тях поотделно и после ги обединя - което е пример за
т. нар. подход на разделяй и владей (divide and conquer) - за да напишете функция mergesort xs,
която приема списък xs и връща списък с елементите на xs сортирани в нарастващ ред.

Пример:
    mergesort [2, 1, 3, 7, -16, 5] = [-16, 1, 2, 3, 5, 7]
-}
-- Ord a => [a] ... означава, че елементите на списъците са сравними по-между си
-- (или че съществува наредба - Ordering - между тях).
merge :: Ord a => [a] -> [a] -> [a]
merge xs ys = undefined

mergesort :: Ord a => [a] -> [a]
mergesort xs = undefined


-- примери от условията на задачите
main = do
    -- Задача 1.
    print (listLength [])
    print (listLength [1, 2, 3, 4])

    -- Задача 2.
    print (3 `isElementOf` [1, 2, 3, 4])
    print (5 `isElementOf` [1, 2, 3, 4])

    -- Задача 3.
    print (interval 1 4)
    print (interval 2 5)
    print (interval 5 2)

    -- Задача 4.
    print (digits 1234)
    print (digits 1750)

    -- Задача 5.
    print (removeDuplicates [1, 2, 1])
    print (removeDuplicates [1, 3, 7, 3, 5, 1])

    -- Задача 6.
    print (merge [1, 3, 7] [2, 4, 6])
    print (mergesort [2, 1, 3, 7, -16, 5])
