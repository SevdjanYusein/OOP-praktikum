const size_t maxNameSize=20;
const size_t maxCountOfProducts=64;

class Product
{
private:
	char name[maxNameSize];
	int expiryDate;
	double fat;
	bool isFood;
	double price;
public:
	Product(char,int,double,bool,double);
	void setname(char);
	void setexpiryDate(int);
	void setfat(double);
	void setisFood(bool);
	void setprice(double);

	char* getName() const
	{
		return this->name;
	}


};

class Store
{
private:
	int countOfProducts;
	Product products[maxCountOfProducts];
	double storeTurnover;
public:

};
__________________________________________________________________________________________________

{- Рекурсивни функции върху числа -}

{- Примери -}
-- 1. Функция, която връща сумата на числата от a до b.
-- Вариант 1. стандартна рекурсия
sum' :: Integer -> Integer -> Integer
sum' a b
    | a > b     = 0                 -- базов случай / дъно на рекурсията
    | otherwise = a + sum' (a + 1) b -- общ случай

-- Вариант 2. опашкова рекурсия:
sum'' :: Integer -> Integer -> Integer
sum'' a b = helper a 0 where
    helper i res =
        if i > b
            then res                        -- в дъното връшаме натрупания резултат (акумулатор)
            else helper (i + 1) (res + i)   -- в общия случай викаме рекурсивно функцията със стойностите от слвдващата "итерация"


-- 2. Функция, която връща факториела на числото n.
-- Вариант 1. стандартна рекурсия
factorial' :: Integer -> Integer
factorial' n =
    if n == 0
    then 1                          -- базов случай / дъно на рекурсията
    else n * factorial' (n - 1)      -- общ случай

factorial'' :: Integer -> Integer
factorial'' n = helper 1 1 where
    helper i res
        | i > n     = res
        | otherwise = helper (i + 1) (res * i)


{- Задачи -}
{-
Задача 1. Най-голям общ делител: Напишете функцията findGCD a b, която приема 2 цели
числа а и b и връща най-големия им общ делител. За целта може да използвате
алгоритъма на Евклид, който гласи, че най-големият общ делител на а и b е 
най-големия общ делител на b и а остатък b ако а не се дели на b или b, ако се.

Не можете да използвате функцията gcd от Прелюдията, която прави точно това.

Примери:
    findGCD 2 1     -> 1
    findGCD 5 15    -> 5
    findGCD 15 35   -> 5
-}
findGCD :: Integer -> Integer -> Integer
findGCD a b = if b == 0 then a else findGCD b (a `mod` b)


{-
Задача 2. Напишете функция, която обръща цифрите на числото n.
Note: Напишете си помощни функции firstDigits и lastDigit.

Примери:
    reverseDigits 0     -> 0
    reverseDigits 5     -> 5
    reverseDigits 12345 -> 54321
    reverseDigits 1212  -> 2121
    reverseDigits 1000  -> 1
-}
lastDigit :: Integer -> Integer
lastDigit n = n `mod` 10

firstDigits :: integer -> Integer
firstDigits n = n `div` 10

reverseDigits :: Integer -> Integer
reverseDigits n = helper 0 n where 
    helper result number = 
       if number == 0
       then result
       else helper (10* result + lastDigit number) (firstDigits number)
       
{-
Задача 3. Прости числа: дефинирайте функцията isPrime n, която приема цялото число n
и проверява дали то е просто.

Примери:
    isPrime 1   -> False
    isPrime 2   -> True
    isPrime 3   -> True
    isPrime 52  -> False
    isPrime 71  -> True
-}
isPrime :: Integer -> Bool
isPrime n = n >= 2 && helper 2 where
    helper i
       | i > sqrtn = True
       | n `mod` i == 0 = False
       | otherwise = helper (i + 1)
    sqrtn = floor (sqrt (fromIntegral n))


{- 
Задача 4. Дефинирайте функцияга sumPrimes a b, която връща сумата на всички прости числа
в интервала от a до b.

Примери:
    sumPrimes 1 10  -> 17
    sumPrimes 2 5   -> 10
-}
sumPrimes :: Integer -> Integer -> Integer
sumPrimes a b 
    | a > b = 0
    | isPrime a = a+ sumPrimes (a + 1) b
    | otherwise = sumPrimes (a + 1) b

{-
Задача 5. Да се дефинира функцията isPerfectNumber n, която приема целочисления аргумент n и
връща дали той е перфектно число. Перфектно число се нарича всяко чяло число, равно на сбора на
собствeните си делители.

Примери:
    isPerfectNumber 6    -> True
    isPerfectNumber 8    -> False
    isPerfectNumber 28   -> True
    isPerfectNumber 500  -> False
-}
isPerfectNumber :: Integer -> Bool
isPerfectNumber n = sumDivisors 1 == n where
    sumDivisors i
       | i == n = 0
       | n `mod` i == 0 = i + sumDivisors (i + 1)
       | otherwise = sumDivisors (i + 1)

-- примери от условията на задачите
main = do
    -- Задача 1.
    print (findGCD 2 1)
    print (findGCD 5 15)
    print (findGCD 15 35)

    -- -- Задача 2.
    print (reverseDigits 0)
    print (reverseDigits 5)
    print (reverseDigits 12345)
    print (reverseDigits 1212)
    print (reverseDigits 1000)

    -- -- Задача 3.
    print (isPrime 1)
    print (isPrime 2)
    print (isPrime 3)
    print (isPrime 52)
    print (isPrime 71)

    -- -- Задача 4.
    print (sumPrimes 1 10)
    print (sumPrimes 2 5)

    -- -- Задача 5.
    print (isPerfectNumber 6)
    print (isPerfectNumber 8)
    print (isPerfectNumber 28)
    print (isPerfectNumber 500)


______________________________________________________________________________________________________

lastDigit :: Integer -> Integer
lastDigit n = n `mod` 10

firstDigits :: Integer -> Integer
firstDigits n = n `div` 10

numDigits :: Integer -> Integer
numDigits n =
    if n < 10 
    then 1
    else 1 + numDigits (firstDigits n)


{-
Задача. 1. Да се напише предикат isAscending, който връща истина, ако цифрите на
дадено естествено число са в нарастващ ред от първата към последната.

    isAscending 5    -> True
    isAscending 121  -> False
    isAscending 122  -> True
    isAscending 123  -> True
-}
isAscending :: Integer -> Bool
isAscending n =
     if n < 10
     then True
     else (lastDigit n) >= (lastDigit(firstDigits n)) && isAscending (firstDigits n)
{-
Задача. 2. Да се напише функция countOccurrences, намираща броя на срещанията на дадена
цифра d в записа на число n.

    countOccurrences 5 5      -> 1
    countOccurrences 5 25525  -> 3
    countOccurrences 5 12346  -> 0
-}
countOccurrences :: Integer -> Integer -> Integer
countOccurrences d n = if n >= 10
                       then if d == lastDigit n
                            then 1 + countOccurrences d (firstDigits n)
                            else countOccurrences d (firstDigits n)
                       else if d == n
                            then 1
                            else 0
{-
Задача. 3. Напишете функция, която за дадено неотрицателно цяло число проверява
дали на всяка четна позиция в десетичния запис на числото стои нечетна цифра. 
Нека старшата (най-лявата) цифра на числото има позиция 0.

    evenPosOddDigits 5    -> True
    evenPosOddDigits 6    -> False
    evenPosOddDigits 123  -> True
    evenPosOddDigits 122  -> False
-}
evenPosOddDigits :: Integer -> Bool
evenPosOddDigits n 
        | n < 10 = odd n
        | even lastIndex && even (lastDigit n) = False
        | otherwise = evenPosOddDigits (firstDigits n)
        where lastIndex = (numDigits n) - 1

{-
Задача 4. Да се дефинира функция която взима числото, което се образува
от последните n цифри на числото m.

    takeNFromEnd 1 123  -> 3
    takeNFromEnd 2 123  -> 23
    takeNFromEnd 3 123  -> 123
-}
takeNFromEnd :: Integer -> Integer -> Integer
takeNFromEnd n m 
      | n == 0 = 0
      | otherwise = (lastDigit m)  + (takeNFromEnd (n - 1) (firstDigits m)) * 10
{-
Задача. 5. Да се дефинира предикат isAutomorphic, който приема число n и
проверява дали n^2 завършва с цифрите на n.

    isAutomorphic 2   -> False
    isAutomorphic 5   -> True
    isAutomorphic 25  -> True
    isAutomorphic 26  -> False
-}

isAutomorphic :: Integer -> Bool
isAutomorphic n = n == takeNFromEnd (numDigits n) (n ^ 2)

{-
Задача. 6. Да се дефинира функция, която намира броя на срещанията
на многоцифрено число в записа на число n. (Като в задача 2, но не само
с едноцифрени числа.)

    print $ countOccurrences' 11 1111    -> 3
    print $ countOccurrences' 25 125625  -> 2
    print $ countOccurrences' 300 23     -> 0
-}
countOccurrences' :: Integer -> Integer -> Integer
countOccurrences' d n = 


main = do
    print $ isAscending 5
    print $ isAscending 121
    print $ isAscending 122
    print $ isAscending 123

    print $ countOccurrences 5 5
    print $ countOccurrences 5 25525
    print $ countOccurrences 5 12346

    print $ evenPosOddDigits 5
    print $ evenPosOddDigits 6
    print $ evenPosOddDigits 123
    print $ evenPosOddDigits 122

    print $ takeNFromEnd 1 123
    print $ takeNFromEnd 2 123 
    print $ takeNFromEnd 3 123 

    print $ isAutomorphic 2
    print $ isAutomorphic 5
    print $ isAutomorphic 25
    print $ isAutomorphic 26

    print $ countOccurrences' 11 1111
    print $ countOccurrences' 25 125625
    print $ countOccurrences' 300 23
    
